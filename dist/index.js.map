{"version":3,"file":"index.js","sources":["../src/core/astBuilder.ts","../src/core/tokenizer.ts","../src/core/parser.ts","../src/index.ts"],"sourcesContent":["import type {\r\n  ASTAnyValue,\r\n  ASTArray,\r\n  ASTBoolean,\r\n  ASTChildren,\r\n  ASTNaN,\r\n  ASTNull,\r\n  ASTNumber,\r\n  ASTObject,\r\n  ASTObjectKey,\r\n  ASTResult,\r\n  ASTString,\r\n  ASTUndefined,\r\n} from \"../types/ast\";\r\nimport type TokenizerResult from \"../types/tokenizerResult\";\r\n\r\n/**\r\n * Unraw a string to transform for example \\\\n to \\n\r\n * @param rawString\r\n * @returns\r\n */\r\nfunction unrawString(rawString: string) {\r\n  return rawString.replace(/\\\\(.)/g, function (_, char) {\r\n    if (char === \"n\") return \"\\n\";\r\n    if (char === \"r\") return \"\\r\";\r\n    if (char === \"t\") return \"\\t\";\r\n    if (char === \"b\") return \"\\b\";\r\n    if (char === \"f\") return \"\\f\";\r\n    if (char === \"v\") return \"\\v\";\r\n    return char;\r\n  });\r\n}\r\n\r\nclass ASTBuilder {\r\n  /**\r\n   * Return the error message for a given token\r\n   * @param token\r\n   * @returns\r\n   */\r\n  getErrorMessage(token: TokenizerResult) {\r\n    return `\"${token.value}\" is not valid JSON\\nline: ${token.startLine}, column: ${token.startColumn}`;\r\n  }\r\n\r\n  /**\r\n   * Format a string token to remove useless quotes and parse unicode\r\n   * @param str\r\n   * @returns\r\n   */\r\n  private formatStr(str: string) {\r\n    const content =\r\n      /(`|'|\")/.test(str.charAt(0)) &&\r\n      /(`|'|\")/.test(str.charAt(str.length - 1))\r\n        ? str.substring(1, str.length - 1)\r\n        : str;\r\n    return unrawString(content); // turn \\\\n into \\n ...\r\n  }\r\n\r\n  private appendBoolean(token: TokenizerResult): ASTBoolean {\r\n    return {\r\n      type: \"BOOLEAN\",\r\n      value: token.type === \"TRUE_BOOLEAN\" ? true : false,\r\n    };\r\n  }\r\n\r\n  private appendNullValue(token: TokenizerResult): ASTNull {\r\n    return {\r\n      type: \"NULL_VALUE\",\r\n      value: null,\r\n    };\r\n  }\r\n\r\n  private appendUndefinedValue(token: TokenizerResult): ASTUndefined {\r\n    return {\r\n      type: \"UNDEFINED_VALUE\",\r\n      value: undefined,\r\n    };\r\n  }\r\n\r\n  private appendNaNValue(token: TokenizerResult): ASTNaN {\r\n    return {\r\n      type: \"NAN_VALUE\",\r\n      value: NaN,\r\n    };\r\n  }\r\n\r\n  private appendString(token: TokenizerResult): ASTString {\r\n    return {\r\n      type: \"STRING\",\r\n      value: this.formatStr(token.value),\r\n    };\r\n  }\r\n\r\n  private appendArray(token: TokenizerResult): ASTArray {\r\n    return {\r\n      type: \"ARRAY\",\r\n      properties: [],\r\n    };\r\n  }\r\n\r\n  private appendObject(token: TokenizerResult): ASTObject {\r\n    return {\r\n      type: \"OBJECT\",\r\n      properties: [],\r\n    };\r\n  }\r\n\r\n  private appendNumber(token: TokenizerResult): ASTNumber {\r\n    return {\r\n      type: \"NUMBER\",\r\n      value: Number(token.value),\r\n    };\r\n  }\r\n\r\n  private appendKey(token: TokenizerResult): ASTObjectKey {\r\n    return {\r\n      type: \"OBJECT_KEY\",\r\n      name: this.formatStr(token.value),\r\n      value: null,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Build the AST for given tokens\r\n   * @param tokens\r\n   * @returns\r\n   */\r\n  buildAST(tokens: TokenizerResult[]) {\r\n    const tree: ASTResult = { type: \"JSON\", properties: [] };\r\n    const childrens: ASTChildren[] = [tree];\r\n\r\n    let lastScannedToken: TokenizerResult = null;\r\n    for (let i = 0; i < tokens.length; ++i) {\r\n      const actualToken = tokens[i];\r\n      const actualChild = childrens[childrens.length - 1];\r\n\r\n      const addASTBranch = (branch: ASTAnyValue) => {\r\n        if (\"value\" in actualChild) {\r\n          (actualChild as any).value = branch;\r\n        } else actualChild.properties.push(branch as any);\r\n      };\r\n\r\n      if (\r\n        actualToken.type === \"TRUE_BOOLEAN\" ||\r\n        actualToken.type === \"FALSE_BOOLEAN\"\r\n      ) {\r\n        addASTBranch(this.appendBoolean(actualToken));\r\n      } else if (actualToken.type === \"NULL\") {\r\n        addASTBranch(this.appendNullValue(actualToken));\r\n      } else if (actualToken.type === \"UNDEFINED\") {\r\n        addASTBranch(this.appendUndefinedValue(actualToken));\r\n      } else if (actualToken.type === \"NAN\") {\r\n        addASTBranch(this.appendNaNValue(actualToken));\r\n      } else if (actualToken.type === \"NUMBER\") {\r\n        addASTBranch(this.appendNumber(actualToken));\r\n      } else if (\r\n        actualToken.type === \"STRING\" ||\r\n        actualToken.type === \"UNKNOWN\"\r\n      ) {\r\n        if (actualChild.type === \"OBJECT_KEY\" && actualChild.value !== null)\r\n          childrens.pop();\r\n\r\n        if (actualChild.type === \"OBJECT\") {\r\n          const child = this.appendKey(actualToken);\r\n          addASTBranch(child);\r\n          childrens.push(child);\r\n        } else addASTBranch(this.appendString(actualToken));\r\n      } else if (actualToken.type === \"START_BRACKET\") {\r\n        const child = this.appendArray(actualToken);\r\n        addASTBranch(child);\r\n        childrens.push(child);\r\n      } else if (actualToken.type === \"START_BRACE\") {\r\n        const child = this.appendObject(actualToken);\r\n        addASTBranch(child);\r\n        childrens.push(child);\r\n      } else if (actualToken.type === \"END_BRACKET\" && childrens.length !== 1) {\r\n        childrens.pop();\r\n      } else if (actualToken.type === \"END_BRACE\" && childrens.length !== 1) {\r\n        if (actualChild.type === \"OBJECT_KEY\") childrens.pop();\r\n        childrens.pop();\r\n      } else if (actualToken.type === \"COMA\") {\r\n        if (actualChild.type === \"OBJECT_KEY\") childrens.pop();\r\n      } else if (actualToken.type === \"COLON\") {\r\n        //TODO: Actually we skip useless COLON\r\n      }\r\n\r\n      if (actualToken.type !== \"WHITE_SPACE\") lastScannedToken = actualToken;\r\n    }\r\n\r\n    return tree;\r\n  }\r\n}\r\n\r\nexport default ASTBuilder;\r\n","type MatcherResult<T extends Tokens, D extends string, A extends boolean> = {\r\n  type: TokenType<T, D, A>;\r\n  value: string;\r\n  groups?: Record<string, string>;\r\n  index: number;\r\n};\r\n\r\ntype Tokens = {\r\n  [key: string]: RegExp;\r\n};\r\n\r\ntype TokenType<T extends Tokens, D extends string, A extends boolean> =\r\n  | keyof T\r\n  | (A extends true ? D | Omit<string, keyof T | D> : D);\r\n\r\ntype Token<T extends Tokens, D extends string, A extends boolean> = {\r\n  type: TokenType<T, D, A>;\r\n  value: string;\r\n  groups?: Record<string, string>;\r\n  startLine: number;\r\n  endLine: number;\r\n  startColumn: number;\r\n  endColumn: number;\r\n};\r\n\r\ntype Options<T extends Tokens, D extends string, A extends boolean> = {\r\n  tokens: T;\r\n  defaultType: D;\r\n  prioritize?: boolean;\r\n  callback?: (\r\n    token: Token<T, D, A>,\r\n    prevTokens: Token<T, D, A>[]\r\n  ) => Token<T, D, A> | null;\r\n  concatDefaultType?: boolean;\r\n  authorizeAdditionalTokens?: A;\r\n};\r\n\r\nconst defaultOptions = {\r\n  defaultType: \"UNKNOWN\",\r\n  concatDefaultType: true,\r\n} as const satisfies Partial<Options<{}, \"UNKNOWN\", false>>;\r\n\r\ntype ConstructorOptions<\r\n  T extends Tokens,\r\n  D extends string,\r\n  A extends boolean\r\n> = Omit<Options<T, D, A>, keyof typeof defaultOptions> &\r\n  Partial<Pick<Options<T, D, A>, keyof typeof defaultOptions>>;\r\n\r\n/**\r\n * Tokenize any string with given tokens\r\n */\r\nclass Tokenizer<\r\n  T extends Tokens,\r\n  D extends string = \"UNKNOWN\",\r\n  A extends boolean = false\r\n> {\r\n  public static BUILT_IN_RULES = {\r\n    WORD: /\\w+/,\r\n    NUMBER: /\\d+(?:\\.\\d+)?/,\r\n\r\n    ONE_LINE_COMMENT: /\\/\\/.*/,\r\n    MULTIPLE_LINE_COMMENT: /\\/\\*[\\s\\S]*?\\*\\//,\r\n\r\n    STRING: /(\"|'|`)(?<content>(?:\\\\\\1|.)*?)\\1/,\r\n    DOUBLE_QUOTE_STRING: /(\")(?<content>(?:\\\\\\1|.)*?)\\1/,\r\n    SINGLE_QUOTE_STRING: /(')(?<content>(?:\\\\\\1|.)*?)\\1/,\r\n    GRAVE_ACCENT_STRING: /(`)(?<content>(?:\\\\\\1|.)*?)\\1/,\r\n\r\n    WHITE_SPACES: /\\s+/,\r\n    NEW_LINES: /\\n+/,\r\n  } as const satisfies Record<string, RegExp>;\r\n  private options: Options<T, D, A>;\r\n\r\n  constructor(_options: ConstructorOptions<T, D, A>) {\r\n    if (!_options || !_options.tokens)\r\n      throw new Error('Invalide options: \"tokens\" is required');\r\n    this.options = Object.assign({}, defaultOptions, _options);\r\n  }\r\n\r\n  /**\r\n   * Get the default type if no token was match\r\n   * @returns\r\n   */\r\n  getDefaultType(): D {\r\n    return this.options.defaultType;\r\n  }\r\n\r\n  /**\r\n   * Get the list registered of the tokens\r\n   * @returns\r\n   */\r\n  getTokens(): T {\r\n    return this.options.tokens;\r\n  }\r\n\r\n  /**\r\n   * Get the list of tokens name\r\n   * @returns\r\n   */\r\n  getTokensName(): (keyof T | D)[] {\r\n    return [...Object.keys(this.options.tokens), this.getDefaultType()];\r\n  }\r\n\r\n  /**\r\n   * Check if a given token match the start of the string\r\n   * @param str\r\n   * @param type\r\n   * @param reg\r\n   * @returns\r\n   */\r\n  private matcher(\r\n    str: string,\r\n    type: string,\r\n    reg: RegExp\r\n  ): MatcherResult<T, D, A> | null {\r\n    reg.lastIndex = 0;\r\n    const match = reg.exec(str);\r\n\r\n    if (!match) return null;\r\n\r\n    return {\r\n      type,\r\n      value: match[0],\r\n      groups: match.groups,\r\n      index: match.index,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Tokenize a string\r\n   * @param str\r\n   * @returns\r\n   */\r\n  tokenize(str: string): Token<T, D, A>[] {\r\n    if (typeof str !== \"string\") return [];\r\n\r\n    const tokens: Token<T, D, A>[] = [];\r\n\r\n    const defaultType = this.getDefaultType();\r\n    const concatDefaultType = this.options.concatDefaultType;\r\n    const tokensList = Object.entries(this.options.tokens);\r\n\r\n    let index = 0;\r\n    let line = 0;\r\n    let column = 0;\r\n\r\n    while (index < str.length) {\r\n      const remaining = str.slice(index);\r\n\r\n      let result: MatcherResult<T, D, A> | null = null;\r\n\r\n      // Check if any regex is matching\r\n      for (const [type, reg] of tokensList) {\r\n        reg.lastIndex = 0;\r\n        const match = reg.exec(remaining);\r\n        if (match && match.index === 0) {\r\n          result = {\r\n            type,\r\n            value: match[0],\r\n            groups: match.groups,\r\n            index: 0,\r\n          };\r\n          break;\r\n        }\r\n      }\r\n\r\n      // No match -> default token\r\n      if (!result) {\r\n        result = {\r\n          type: defaultType,\r\n          value: remaining[0],\r\n          index: 0,\r\n        };\r\n      }\r\n\r\n      // Line, column calculation\r\n      const value = result.value;\r\n      const lines = value.split(\"\\n\");\r\n      const startLine = line;\r\n      const startColumn = column;\r\n      let endLine = line;\r\n      let endColumn = column;\r\n\r\n      if (lines.length > 1) {\r\n        endLine = line + lines.length - 1;\r\n        endColumn = lines[lines.length - 1].length;\r\n      } else {\r\n        endColumn = column + value.length;\r\n      }\r\n\r\n      // Update current line/column\r\n      line = endLine;\r\n      column = endColumn;\r\n\r\n      let token: Token<T, D, A> | null = {\r\n        type: result.type,\r\n        value: result.value,\r\n        ...(result.groups ? { groups: result.groups } : {}),\r\n        startLine,\r\n        startColumn,\r\n        endLine,\r\n        endColumn,\r\n      };\r\n\r\n      token = this.options.callback\r\n        ? this.options.callback(token, tokens)\r\n        : token;\r\n\r\n      // We update the char index based on what we have match\r\n      index += value.length;\r\n\r\n      // Check the new token returned by the callback\r\n      if (token === null) continue;\r\n      if (\r\n        !this.options.authorizeAdditionalTokens &&\r\n        !this.getTokensName().includes(token.type as keyof T | D)\r\n      ) {\r\n        throw new Error(\r\n          `Unknown token type returned by the callback: \"${\r\n            token.type as string\r\n          }\" (If you want to allow other types please set authorizeAdditionalTokens to true)`\r\n        );\r\n      }\r\n\r\n      const isTokenDefaultType = token.type === defaultType;\r\n      const needConcatenation =\r\n        concatDefaultType &&\r\n        isTokenDefaultType &&\r\n        tokens.length !== 0 &&\r\n        tokens[tokens.length - 1].type === defaultType;\r\n      if (needConcatenation) {\r\n        // Concatenation with the last token if needed\r\n        const lastToken = tokens[tokens.length - 1];\r\n        lastToken.value += token.value;\r\n        lastToken.endColumn = token.endColumn;\r\n        lastToken.endLine = token.endLine;\r\n      } else {\r\n        tokens.push(token);\r\n      }\r\n    }\r\n\r\n    return tokens;\r\n  }\r\n}\r\n\r\nexport default Tokenizer;\r\n","import type { ASTArray, ASTObject, ASTResult, ASTSimple } from \"../types/ast\";\r\nimport ASTBuilder from \"./astBuilder\";\r\nimport Tokenizer from \"./tokenizer\";\r\n\r\nconst TOKENS = {\r\n  STRING: /^(\"|'|`)(?:\\\\\\1|.|\\n)*?\\1/,\r\n  NUMBER: /^-?(?:\\d+(?:\\.\\d*)?|\\.\\d+)/,\r\n  WHITE_SPACE: /^\\s+/,\r\n  COMA: /^,/,\r\n  COLON: /^:/,\r\n  TRUE_BOOLEAN: /^true/,\r\n  FALSE_BOOLEAN: /^false/,\r\n  NULL: /^null/,\r\n  UNDEFINED: /^undefined/,\r\n  NAN: /^NaN/,\r\n  START_BRACKET: /^\\[/,\r\n  END_BRACKET: /^\\]/,\r\n  START_BRACE: /^\\{/,\r\n  END_BRACE: /^\\}/,\r\n} as const;\r\n\r\n/**\r\n * JSON parser for a given string\r\n */\r\nclass Parser {\r\n  private tokenizer = new Tokenizer({\r\n    tokens: TOKENS,\r\n  });\r\n  private astBuilder = new ASTBuilder();\r\n\r\n  /**\r\n   * Parse a JSON string and return the object\r\n   * @param str\r\n   * @returns\r\n   */\r\n  parse<T = any>(str?: string | null | boolean | number | undefined): T {\r\n    str = String(str);\r\n    const tokens = this.tokenizer.tokenize(str);\r\n    const ast = this.astBuilder.buildAST(tokens);\r\n    if (ast.properties.length > 1)\r\n      return ast.properties.map((property) =>\r\n        this.parseASTBranch(property)\r\n      ) as T;\r\n    return (\r\n      ast.properties.length > 0\r\n        ? this.parseASTBranch(ast.properties[0])\r\n        : undefined\r\n    ) as T;\r\n  }\r\n\r\n  private parseASTBranch(astBranch: ASTResult[\"properties\"][number]) {\r\n    if (astBranch.type === \"OBJECT\") {\r\n      return this.parseObject(astBranch);\r\n    }\r\n\r\n    if (astBranch.type === \"ARRAY\") {\r\n      return this.parseArray(astBranch);\r\n    }\r\n\r\n    return this.parsePrimitif(astBranch);\r\n  }\r\n\r\n  private parseArray(astBranch: ASTArray) {\r\n    const json: any[] = [];\r\n    for (const property of astBranch.properties) {\r\n      json.push(this.parseASTBranch(property));\r\n    }\r\n    return json;\r\n  }\r\n\r\n  private parseObject(astBranch: ASTObject) {\r\n    const json: any = {};\r\n    for (const property of astBranch.properties) {\r\n      if (property.type !== \"OBJECT_KEY\") continue;\r\n      json[property.name] =\r\n        property.value === null ? null : this.parseASTBranch(property.value);\r\n    }\r\n    return json;\r\n  }\r\n\r\n  private parsePrimitif(astBranch: ASTSimple): any {\r\n    return astBranch.value;\r\n  }\r\n}\r\n\r\nexport default Parser;\r\n","import Parser from \"./core/parser\";\r\n\r\nconst parser = new Parser();\r\n\r\nexport default parser.parse.bind(parser) as Parser[\"parse\"];\r\n"],"names":["ASTBuilder","getErrorMessage","token","value","startLine","startColumn","formatStr","str","content","test","charAt","length","substring","replace","_","char","appendBoolean","type","appendNullValue","appendUndefinedValue","undefined","appendNaNValue","NaN","appendString","this","appendArray","properties","appendObject","appendNumber","Number","appendKey","name","buildAST","tokens","tree","childrens","i","actualToken","actualChild","addASTBranch","branch","push","pop","child","defaultOptions","defaultType","concatDefaultType","Tokenizer","constructor","_options","Error","options","Object","assign","getDefaultType","getTokens","getTokensName","keys","matcher","reg","lastIndex","match","exec","groups","index","tokenize","tokensList","entries","line","column","remaining","slice","result","lines","split","endLine","endColumn","callback","authorizeAdditionalTokens","includes","isTokenDefaultType","lastToken","BUILT_IN_RULES","WORD","NUMBER","ONE_LINE_COMMENT","MULTIPLE_LINE_COMMENT","STRING","DOUBLE_QUOTE_STRING","SINGLE_QUOTE_STRING","GRAVE_ACCENT_STRING","WHITE_SPACES","NEW_LINES","TOKENS","WHITE_SPACE","COMA","COLON","TRUE_BOOLEAN","FALSE_BOOLEAN","NULL","UNDEFINED","NAN","START_BRACKET","END_BRACKET","START_BRACE","END_BRACE","parser","tokenizer","astBuilder","parse","String","ast","map","property","parseASTBranch","astBranch","parseObject","parseArray","parsePrimitif","json","bind"],"mappings":"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"}